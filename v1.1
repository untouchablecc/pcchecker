import os
import subprocess
import requests
import json
import time
import platform
import getpass
import tempfile
from datetime import datetime
from filelock import FileLock, Timeout

# Webhook URLs
WEBHOOK_URLS = {
    'system_processes': 'https://canary.discord.com/api/webhooks/1279137428371931248/eYRZf4HRZ5GmYXgLI_iRA5WiOhqVSFBDGn_ztg-oRrNrSWmdKq69WC0MX9P9nQuutQac',
    'admin_processes': 'https://canary.discord.com/api/webhooks/1279137428371931248/eYRZf4HRZ5GmYXgLI_iRA5WiOhqVSFBDGn_ztg-oRrNrSWmdKq69WC0MX9P9nQuutQac',
    'process_traces': 'https://canary.discord.com/api/webhooks/1279148419193114694/l4pr5CEMMlD4LDsZ9_plYFSfTgWCVvWqXCN9Gri6XVq8bRL55GZtgNZXGOU1TrY34SCV',
    'database': 'https://canary.discord.com/api/webhooks/1279407337618145310/A7fONuJnsWJLLCwkB2XlNKga0XeQwO6yq3HjWzhHt6hqzafunlxxeIO_dpebSN_DcunP',
    'recent_activity': 'https://canary.discord.com/api/webhooks/1279411390314057820/85pPrwRUCeX3EoLCexlHK0LOyAf9m9pRmRO3GIgZZMhMdm_gxAbMLWSE_0T6MXNhiWgK',
    'error': 'https://canary.discord.com/api/webhooks/1279188293438799902/S3ejH4YpQBv-7Yp4TfW8LCezK-UpzVxolIwdcX66uN-DQZ2DiXt-X2QdeL2mM9ky5Siz'
}

# Paths
ERROR_LOG_PATH = os.path.join(tempfile.gettempdir(), 'error_log.txt')

# Webhook delay (in seconds)
WEBHOOK_DELAY = 1

def send_embed_to_webhook(title, description, color, url):
    """Send a message to the webhook with an embedded format."""
    max_description_length = 2000
    descriptions = [description[i:i+max_description_length] for i in range(0, len(description), max_description_length)]

    for desc in descriptions:
        embed = {
            "embeds": [
                {
                    "title": title,
                    "description": desc,
                    "color": color
                }
            ]
        }
        try:
            response = requests.post(url, json=embed)
            response.raise_for_status()
            print_status(f"Embed sent to webhook: {title}", 'success')
        except requests.RequestException as e:
            log_error(f"Failed to send embed to webhook: {e}")
        
        time.sleep(WEBHOOK_DELAY)  # Ensure delay between webhook requests

def print_status(message, status='normal'):
    """Print status messages with color coding for real-time feedback."""
    color_code = {
        'error': '91',     # Red
        'warning': '93',   # Yellow
        'success': '92',   # Green
        'normal': '0'      # Default
    }
    print(f"\033[{color_code[status]}m{message}\033[0m")

def log_error(message):
    """Log errors to a text file and also send to the error webhook."""
    print_status(message, 'error')
    
    # Create 'output' directory if it doesn't exist
    os.makedirs(os.path.dirname(ERROR_LOG_PATH), exist_ok=True)
    
    # Use filelock to handle file access issues
    lock_path = ERROR_LOG_PATH + '.lock'
    lock = FileLock(lock_path, timeout=10)

    try:
        with lock:
            with open(ERROR_LOG_PATH, 'a') as f:
                f.write(f"{datetime.now()}: {message}\n")
    except IOError as e:
        print_status(f"Failed to write to error log: {e}", 'error')
    
    # Send to webhook
    send_embed_to_webhook(
        "Error Log",
        message,
        0xFF0000,  # Red color
        WEBHOOK_URLS['error']
    )

def run_command(command):
    """Execute a command and return its output or an error message."""
    try:
        result = subprocess.check_output(command, shell=True, text=True).strip()
        return result, None
    except subprocess.CalledProcessError as e:
        return None, str(e)

def safe_open_file(file_path, mode='r', retries=5, delay=1):
    """Attempt to open a file with retries in case of file lock errors."""
    for attempt in range(retries):
        try:
            with open(file_path, mode) as f:
                return f
        except IOError as e:
            if 'locked' in str(e).lower():
                print_status(f"File is locked: {file_path}. Retrying in {delay} seconds...", 'warning')
                time.sleep(delay)
            else:
                raise
    raise IOError(f"Failed to open file after {retries} attempts: {file_path}")

def scan_directory(directory, file_names=None):
    """Recursively scan a directory for specific files."""
    results = {file: [] for file in file_names} if file_names else []
    total_files = 0
    scanned_files = 0
    directories_to_scan = [directory]

    while directories_to_scan:
        current_dir = directories_to_scan.pop()
        if not os.path.exists(current_dir):
            log_error(f"Directory does not exist: {current_dir}")
            continue
        
        try:
            with os.scandir(current_dir) as it:
                for entry in it:
                    if entry.is_dir(follow_symlinks=False):
                        directories_to_scan.append(entry.path)
                    elif file_names:
                        for file in file_names:
                            if file.lower() in entry.name.lower():
                                path = entry.path
                                results[file].append(path)
                                print_status(f"Found file: {path}", 'warning')
                    scanned_files += 1
                    total_files += 1
        except PermissionError:
            log_error(f"Permission denied: {current_dir}")
            continue
        except IOError as e:
            log_error(f"IOError while scanning directory {current_dir}: {e}")

    return results, total_files, scanned_files

def get_processes():
    command = 'powershell -ExecutionPolicy Bypass -Command "Get-Process | Select-Object -Property Name, Id, Path | ConvertTo-Json"'
    output, error = run_command(command)
    if error:
        log_error(f"Failed to get processes: {error}")
    else:
        print_status("Retrieved processes.", 'success')
    return output or f"Error: {error}"

def get_admin_processes():
    command = 'powershell -ExecutionPolicy Bypass -Command "Get-Process | Where-Object { $_.Path -like \'C:\\Windows\\System32\\*\' -or $_.Path -like \'C:\\Program Files*\\*\' } | Select-Object -Property Name, Id, Path | ConvertTo-Json"'
    output, error = run_command(command)
    if error:
        log_error(f"Failed to get admin processes: {error}")
    else:
        print_status("Retrieved admin processes.", 'success')
    return output or f"Error: {error}"

def format_processes(processes):
    try:
        processes_json = json.loads(processes)
        formatted = []
        for process in processes_json:
            name = process.get("Name", "Unknown")
            pid = process.get("Id", "Unknown")
            path = process.get("Path", "Unknown")
            formatted.append(f"**{name}** (ID: {pid})\nPath: {path}")
        return "\n".join(formatted) if formatted else "No processes detected"
    except json.JSONDecodeError as e:
        log_error(f"Format Processes Error: {e}")
        return f"Error decoding process data: {str(e)}"

def find_process_traces(name):
    """Find all traces of the specific process."""
    traces = []
    directories = [
        'C:\\Windows\\System32',
        'C:\\Program Files',
        'C:\\Program Files (x86)',
        'C:\\Users\\Public',
        'C:\\Windows\\Temp',
        'C:\\Users\\%USERNAME%\\AppData\\Local',
        'C:\\Users\\%USERNAME%\\AppData\\Roaming',
        'C:\\$Recycle.Bin',
        'C:\\ProgramData',
        'C:\\Documents and Settings',
        'C:\\$Windows.~BT'
    ]

    # Scan specified directories
    for directory in directories:
        directory = directory.replace('%USERNAME%', getpass.getuser())
        if os.path.exists(directory):
            print_status(f"Scanning directory: {directory}", 'normal')
            for root, dirs, files in os.walk(directory):
                for file in files:
                    if name.lower() in file.lower():
                        path = os.path.join(root, file)
                        traces.append(path)
    return traces

def handle_recent_activities():
    """Retrieve and handle recent activities."""
    try:
        user = getpass.getuser()
        log_path = os.path.join(os.getenv('USERPROFILE', ''), 'AppData', 'Local', 'Microsoft', 'Windows', 'Logs', 'Application')
        recent_activities = []
        if os.path.exists(log_path):
            for root, dirs, files in os.walk(log_path):
                for file in files:
                    if file.lower().endswith('.log'):
                        path = os.path.join(root, file)
                        recent_activities.append(path)
        return recent_activities
    except Exception as e:
        log_error(f"Failed to retrieve recent activities: {e}")
        return []

def handle_error(message):
    """Handle errors in the script."""
    log_error(message)

def main():
    """Main function to handle user choices and execute actions."""
    while True:
        print_status("\nChoose an option:\n1. Active Processes\n2. Admin Processes\n3. Process Traces\n4. Recent Activities\n5. Exit", 'normal')
        choice = input("Enter choice: ").strip()

        if choice == '1':
            processes = get_processes()
            formatted_processes = format_processes(processes)
            send_embed_to_webhook("Active Processes", formatted_processes, 0x00FF00, WEBHOOK_URLS['system_processes'])
        elif choice == '2':
            admin_processes = get_admin_processes()
            formatted_admin_processes = format_processes(admin_processes)
            send_embed_to_webhook("Admin Processes", formatted_admin_processes, 0xFFFF00, WEBHOOK_URLS['admin_processes'])
        elif choice == '3':
            name = input("Enter process name to search for: ").strip()
            traces = find_process_traces(name)
            if traces:
                formatted_traces = "\n".join(traces)
                send_embed_to_webhook("Process Traces", formatted_traces, 0x0000FF, WEBHOOK_URLS['process_traces'])
            else:
                send_embed_to_webhook("Process Traces", "No traces found.", 0x0000FF, WEBHOOK_URLS['process_traces'])
        elif choice == '4':
            recent_activities = handle_recent_activities()
            if recent_activities:
                formatted_activities = "\n".join(recent_activities)
                send_embed_to_webhook("Recent Activities", formatted_activities, 0x00FFFF, WEBHOOK_URLS['recent_activity'])
            else:
                send_embed_to_webhook("Recent Activities", "No recent activities found.", 0x00FFFF, WEBHOOK_URLS['recent_activity'])
        elif choice == '5':
            print_status("Exiting the program.", 'success')
            break
        else:
            print_status("Invalid choice. Please try again.", 'error')

if __name__ == "__main__":
    main()
